import { detectPatterns } from "./patternMatching";
import { analyzeWithAI } from "./aiAnalysis";

export interface Vulnerability {
  id: string;
  type: string;
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";
  line: number;
  column?: number;
  message: string;
  suggestion: string;
  confidence: number;
  detectionMethod: "PATTERN" | "AI" | "HYBRID";
}

export interface ScanResult {
  vulnerabilities: Vulnerability[];
  securityScore: number;
  scanTime: number;
  linesScanned: number;
}

export async function scanCode(code: string, fileName: string): Promise<ScanResult> {
  const startTime = Date.now();
  const lines = code.split('\n');
  
  try {
    // Pattern-based detection (always available)
    const patternVulnerabilities = detectPatterns(code, fileName);
    
    // AI-based detection (when available)
    let aiVulnerabilities: Vulnerability[] = [];
    try {
      if (process.env.VITE_OPENAI_API_KEY) {
        aiVulnerabilities = await analyzeWithAI(code, fileName);
      }
    } catch (error) {
      console.warn("AI analysis unavailable, falling back to pattern matching only");
    }
    
    // Combine and deduplicate vulnerabilities
    const allVulnerabilities = [...patternVulnerabilities, ...aiVulnerabilities];
    const uniqueVulnerabilities = deduplicateVulnerabilities(allVulnerabilities);
    
    // Calculate security score
    const securityScore = calculateSecurityScore(uniqueVulnerabilities, lines.length);
    
    const scanTime = Date.now() - startTime;
    
    return {
      vulnerabilities: uniqueVulnerabilities,
      securityScore,
      scanTime,
      linesScanned: lines.length
    };
  } catch (error) {
    console.error("Scanning error:", error);
    throw new Error("Failed to scan code");
  }
}

function deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
  const seen = new Set<string>();
  return vulnerabilities.filter(vuln => {
    const key = `${vuln.type}-${vuln.line}-${vuln.message}`;
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

function calculateSecurityScore(vulnerabilities: Vulnerability[], linesOfCode: number): number {
  if (linesOfCode === 0) return 100;
  
  // Base score starts at 100
  let score = 100;
  
  // Deduct points based on vulnerability severity
  vulnerabilities.forEach(vuln => {
    switch (vuln.severity) {
      case "CRITICAL":
        score -= 20;
        break;
      case "HIGH":
        score -= 10;
        break;
      case "MEDIUM":
        score -= 5;
        break;
      case "LOW":
        score -= 2;
        break;
    }
  });
  
  // Factor in code complexity (more lines = potentially more attack surface)
  const complexityPenalty = Math.min(10, Math.floor(linesOfCode / 100));
  score -= complexityPenalty;
  
  // Ensure score is between 0 and 100
  return Math.max(0, Math.min(100, Math.round(score)));
}

export function getSeverityColor(severity: string): string {
  switch (severity) {
    case "CRITICAL":
      return "text-red-600 dark:text-red-400";
    case "HIGH":
      return "text-orange-600 dark:text-orange-400";
    case "MEDIUM":
      return "text-yellow-600 dark:text-yellow-400";
    case "LOW":
      return "text-blue-600 dark:text-blue-400";
    default:
      return "text-gray-600 dark:text-gray-400";
  }
}

export function getSeverityBgColor(severity: string): string {
  switch (severity) {
    case "CRITICAL":
      return "bg-red-100 dark:bg-red-900/30 border-red-200 dark:border-red-800";
    case "HIGH":
      return "bg-orange-100 dark:bg-orange-900/30 border-orange-200 dark:border-orange-800";
    case "MEDIUM":
      return "bg-yellow-100 dark:bg-yellow-900/30 border-yellow-200 dark:border-yellow-800";
    case "LOW":
      return "bg-blue-100 dark:bg-blue-900/30 border-blue-200 dark:border-blue-800";
    default:
      return "bg-gray-100 dark:bg-gray-900/30 border-gray-200 dark:border-gray-800";
  }
}
