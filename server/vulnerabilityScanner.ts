import { analyzeCodeSecurity } from "./gemini";

interface Vulnerability {
  type: string;
  severity: "low" | "medium" | "high" | "critical";
  line?: number;
  column?: number;
  message: string;
  suggestion?: string;
  confidence: number;
}

interface ScanResult {
  vulnerabilities: Vulnerability[];
  securityScore: number;
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
}

// Advanced pattern-based vulnerability detection
const VULNERABILITY_PATTERNS = {
  sql_injection: {
    patterns: [
      /\$\{.*\}.*SELECT|INSERT|UPDATE|DELETE/gi, // Template literal SQL injection
      /["']\s*\+\s*.*\s*\+\s*["'].*SELECT|INSERT|UPDATE|DELETE/gi, // String concatenation
      /.*(SELECT|INSERT|UPDATE|DELETE).*\+.*["'].*["']/gi,
      /query\s*=\s*["'`].*\$\{.*\}/gi,
      /execute\(\s*["'`].*\+/gi,
    ],
    severity: "critical" as const,
    message: "Potential SQL injection vulnerability detected",
    suggestion: "Use parameterized queries or prepared statements"
  },
  xss: {
    patterns: [
      /innerHTML\s*=\s*.*[^)]\s*$/gmi, // Direct innerHTML assignment
      /document\.write\s*\(/gi,
      /\.html\(\s*[^)]*\+/gi, // jQuery html() with concatenation
      /dangerouslySetInnerHTML/gi,
      /eval\s*\(/gi,
    ],
    severity: "high" as const,
    message: "Cross-Site Scripting (XSS) vulnerability detected",
    suggestion: "Sanitize user input and use safe DOM manipulation methods"
  },
  hardcoded_secrets: {
    patterns: [
      /(?:password|pwd|pass)\s*[:=]\s*["'][^"']{3,}["']/gi,
      /(?:api[_-]?key|apikey)\s*[:=]\s*["'][^"']{10,}["']/gi,
      /(?:secret|token)\s*[:=]\s*["'][^"']{10,}["']/gi,
      /(?:private[_-]?key)\s*[:=]\s*["'][^"']{20,}["']/gi,
      /(?:access[_-]?token)\s*[:=]\s*["'][^"']{10,}["']/gi,
    ],
    severity: "high" as const,
    message: "Hardcoded credentials or secrets detected",
    suggestion: "Use environment variables or secure key management systems"
  },
  path_traversal: {
    patterns: [
      /\.\.[\/\\]/g, // Directory traversal
      /path\.join\([^)]*\.\./gi,
      /readFile\([^)]*\+/gi, // File read with concatenation
      /writeFile\([^)]*\+/gi,
    ],
    severity: "high" as const,
    message: "Path traversal vulnerability detected",
    suggestion: "Validate and sanitize file paths, use path.resolve()"
  },
  command_injection: {
    patterns: [
      /exec\([^)]*\+/gi, // Command execution with concatenation
      /spawn\([^)]*\+/gi,
      /system\([^)]*\+/gi,
      /shell_exec\([^)]*\+/gi,
    ],
    severity: "critical" as const,
    message: "Command injection vulnerability detected",
    suggestion: "Use parameterized commands or whitelist allowed operations"
  },
  insecure_randomness: {
    patterns: [
      /Math\.random\(\)/gi,
      /rand\(\)/gi,
      /srand\(/gi,
    ],
    severity: "medium" as const,
    message: "Insecure random number generation",
    suggestion: "Use cryptographically secure random number generators"
  },
  weak_crypto: {
    patterns: [
      /MD5|SHA1(?!.*SHA1[0-9])/gi,
      /DES(?!.*AES)/gi,
      /RC4/gi,
      /createHash\(['"]md5['"]|createHash\(['"]sha1['"]/gi,
    ],
    severity: "medium" as const,
    message: "Weak cryptographic algorithm detected",
    suggestion: "Use strong cryptographic algorithms like AES-256, SHA-256"
  },
  missing_input_validation: {
    patterns: [
      /req\.body\.[^;]*(?!.*validation|.*sanitize|.*escape)/gi,
      /req\.query\.[^;]*(?!.*validation|.*sanitize|.*escape)/gi,
      /req\.params\.[^;]*(?!.*validation|.*sanitize|.*escape)/gi,
    ],
    severity: "medium" as const,
    message: "Missing input validation detected",
    suggestion: "Implement proper input validation and sanitization"
  },
  insecure_cors: {
    patterns: [
      /Access-Control-Allow-Origin.*\*/gi,
      /cors\(\{.*origin:\s*true/gi,
      /cors\(\{.*origin:\s*"?\*"?/gi,
    ],
    severity: "medium" as const,
    message: "Insecure CORS configuration",
    suggestion: "Restrict CORS to specific trusted origins"
  },
  debug_info_leak: {
    patterns: [
      /console\.log\([^)]*password|console\.log\([^)]*secret|console\.log\([^)]*token/gi,
      /print\([^)]*password|print\([^)]*secret|print\([^)]*token/gi,
      /debug.*true/gi,
    ],
    severity: "low" as const,
    message: "Potential information disclosure in debug output",
    suggestion: "Remove debug statements in production code"
  }
};

export async function scanCode(code: string, language: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];
  
  // Pattern-based scanning
  for (const [vulnType, config] of Object.entries(VULNERABILITY_PATTERNS)) {
    for (const pattern of config.patterns) {
      let match;
      while ((match = pattern.exec(code)) !== null) {
        const lines = code.substring(0, match.index).split('\n');
        const line = lines.length;
        const column = lines[lines.length - 1].length;
        
        vulnerabilities.push({
          type: vulnType.replace(/_/g, ' ').toUpperCase(),
          severity: config.severity,
          line,
          column,
          message: config.message,
          suggestion: config.suggestion,
          confidence: 0.8 // Pattern matching confidence
        });
      }
    }
  }
  
  // AI-powered analysis
  try {
    const aiAnalysis = await analyzeCodeSecurity(code, language);
    if (aiAnalysis && aiAnalysis.vulnerabilities) {
      vulnerabilities.push(...aiAnalysis.vulnerabilities.map(v => ({
        ...v,
        confidence: v.confidence || 0.9 // AI analysis typically has higher confidence
      })));
    }
  } catch (error) {
    console.warn("AI analysis failed, falling back to pattern matching only:", error);
  }
  
  // Remove duplicates and calculate security score
  const uniqueVulnerabilities = deduplicateVulnerabilities(vulnerabilities);
  const securityScore = calculateSecurityScore(uniqueVulnerabilities, code.length);
  
  const summary = {
    critical: uniqueVulnerabilities.filter(v => v.severity === "critical").length,
    high: uniqueVulnerabilities.filter(v => v.severity === "high").length,
    medium: uniqueVulnerabilities.filter(v => v.severity === "medium").length,
    low: uniqueVulnerabilities.filter(v => v.severity === "low").length,
  };
  
  return {
    vulnerabilities: uniqueVulnerabilities,
    securityScore,
    summary
  };
}

export async function scanFile(filePath: string, content: string): Promise<ScanResult> {
  const language = getLanguageFromExtension(filePath);
  return scanCode(content, language);
}

export async function scanProject(project: any): Promise<ScanResult> {
  const allVulnerabilities: Vulnerability[] = [];
  let totalLines = 0;
  
  if (project.files && Array.isArray(project.files)) {
    for (const file of project.files) {
      if (file.content) {
        const fileResult = await scanFile(file.path, file.content);
        allVulnerabilities.push(...fileResult.vulnerabilities.map(v => ({
          ...v,
          file: file.path
        })));
        totalLines += file.content.split('\n').length;
      }
    }
  }
  
  const uniqueVulnerabilities = deduplicateVulnerabilities(allVulnerabilities);
  const securityScore = calculateSecurityScore(uniqueVulnerabilities, totalLines);
  
  const summary = {
    critical: uniqueVulnerabilities.filter(v => v.severity === "critical").length,
    high: uniqueVulnerabilities.filter(v => v.severity === "high").length,
    medium: uniqueVulnerabilities.filter(v => v.severity === "medium").length,
    low: uniqueVulnerabilities.filter(v => v.severity === "low").length,
  };
  
  return {
    vulnerabilities: uniqueVulnerabilities,
    securityScore,
    summary
  };
}

function deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
  const seen = new Set<string>();
  return vulnerabilities.filter(vuln => {
    const key = `${vuln.type}-${vuln.line}-${vuln.column}-${vuln.message}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

function calculateSecurityScore(vulnerabilities: Vulnerability[], codeLength: number): number {
  if (codeLength === 0) return 100;
  
  const weights = {
    critical: 25,
    high: 15,
    medium: 8,
    low: 3
  };
  
  let penalty = 0;
  for (const vuln of vulnerabilities) {
    penalty += weights[vuln.severity] * vuln.confidence;
  }
  
  // Normalize by code length (per 1000 lines)
  const normalizedPenalty = (penalty / codeLength) * 1000;
  
  // Calculate score (0-100, where 100 is perfect security)
  const score = Math.max(0, 100 - normalizedPenalty);
  
  return Math.round(score * 10) / 10; // Round to 1 decimal place
}

function getLanguageFromExtension(filePath: string): string {
  const ext = filePath.split('.').pop()?.toLowerCase();
  const languageMap: Record<string, string> = {
    'js': 'javascript',
    'jsx': 'javascript',
    'ts': 'typescript',
    'tsx': 'typescript',
    'py': 'python',
    'java': 'java',
    'php': 'php',
    'rb': 'ruby',
    'go': 'go',
    'rs': 'rust',
    'cpp': 'cpp',
    'c': 'c',
    'cs': 'csharp',
    'html': 'html',
    'css': 'css',
    'sql': 'sql'
  };
  
  return languageMap[ext || ''] || 'text';
}
