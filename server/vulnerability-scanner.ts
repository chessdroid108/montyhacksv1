import OpenAI from "openai";
import type { File, InsertVulnerability } from "@shared/schema";

interface VulnerabilityPattern {
  id: string;
  name: string;
  pattern: RegExp;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  suggestion: string;
  languages: string[];
}

interface ScanResult {
  vulnerabilities: Omit<InsertVulnerability, 'scanId'>[];
  securityScore: number;
}

export class VulnerabilityScanner {
  private openai: OpenAI | null = null;
  private patterns: VulnerabilityPattern[] = [];

  constructor() {
    // Initialize OpenAI if API key is available
    const apiKey = process.env.OPENAI_API_KEY;
    if (apiKey && apiKey !== "default_key") {
      this.openai = new OpenAI({ apiKey });
    }

    this.initializePatterns();
  }

  private initializePatterns() {
    this.patterns = [
      // SQL Injection patterns
      {
        id: 'sql_injection_concat',
        name: 'SQL Injection via String Concatenation',
        pattern: /(SELECT|INSERT|UPDATE|DELETE).*(\+|concat|\|\|).*['"]\s*\+\s*\w+/gi,
        severity: 'critical',
        description: 'Direct string concatenation in SQL queries allows injection attacks',
        suggestion: 'Use parameterized queries or prepared statements',
        languages: ['javascript', 'typescript', 'php', 'python', 'java', 'csharp']
      },
      {
        id: 'sql_injection_template',
        name: 'SQL Injection via Template Literals',
        pattern: /`(SELECT|INSERT|UPDATE|DELETE).*\$\{[^}]+\}`/gi,
        severity: 'critical',
        description: 'Template literals with user input in SQL queries are vulnerable to injection',
        suggestion: 'Use parameterized queries instead of template literals',
        languages: ['javascript', 'typescript']
      },
      {
        id: 'sql_injection_format',
        name: 'SQL Injection via String Formatting',
        pattern: /(SELECT|INSERT|UPDATE|DELETE).*(%s|%d|\{[^}]*\}|\.format\()/gi,
        severity: 'critical',
        description: 'String formatting in SQL queries can lead to injection vulnerabilities',
        suggestion: 'Use parameterized queries or ORM methods',
        languages: ['python', 'java', 'csharp']
      },

      // XSS patterns
      {
        id: 'xss_innerhtml',
        name: 'Cross-Site Scripting via innerHTML',
        pattern: /\.innerHTML\s*=\s*[^;]*['"]\s*\+/gi,
        severity: 'high',
        description: 'Setting innerHTML with concatenated user input allows XSS attacks',
        suggestion: 'Use textContent or sanitize input before setting innerHTML',
        languages: ['javascript', 'typescript']
      },
      {
        id: 'xss_eval',
        name: 'Dangerous eval() Usage',
        pattern: /eval\s*\([^)]*['"]\s*\+/gi,
        severity: 'critical',
        description: 'Using eval() with user input can execute malicious code',
        suggestion: 'Avoid eval() or use safer alternatives like JSON.parse()',
        languages: ['javascript', 'typescript']
      },
      {
        id: 'xss_document_write',
        name: 'XSS via document.write',
        pattern: /document\.write\s*\([^)]*['"]\s*\+/gi,
        severity: 'high',
        description: 'document.write with user input can lead to XSS vulnerabilities',
        suggestion: 'Use DOM manipulation methods instead of document.write',
        languages: ['javascript', 'typescript']
      },

      // Authentication/Authorization issues
      {
        id: 'hardcoded_password',
        name: 'Hardcoded Password',
        pattern: /(password|pwd|pass)\s*[=:]\s*['"'][^'"]{4,}['"']/gi,
        severity: 'high',
        description: 'Hardcoded passwords in source code are security risks',
        suggestion: 'Use environment variables or secure credential storage',
        languages: ['javascript', 'typescript', 'python', 'java', 'php', 'csharp']
      },
      {
        id: 'hardcoded_api_key',
        name: 'Hardcoded API Key',
        pattern: /(api[_-]?key|apikey|access[_-]?key|secret[_-]?key)\s*[=:]\s*['"'][a-zA-Z0-9]{10,}['"']/gi,
        severity: 'critical',
        description: 'Hardcoded API keys should not be stored in source code',
        suggestion: 'Use environment variables or secure key management services',
        languages: ['javascript', 'typescript', 'python', 'java', 'php', 'csharp']
      },
      {
        id: 'weak_crypto',
        name: 'Weak Cryptographic Algorithm',
        pattern: /(md5|sha1|des|rc4)\s*\(/gi,
        severity: 'medium',
        description: 'Weak cryptographic algorithms are vulnerable to attacks',
        suggestion: 'Use stronger algorithms like SHA-256, AES, or bcrypt',
        languages: ['javascript', 'typescript', 'python', 'java', 'php', 'csharp']
      },

      // Input validation issues
      {
        id: 'missing_input_validation',
        name: 'Missing Input Validation',
        pattern: /req\.(body|query|params)\.[a-zA-Z_][a-zA-Z0-9_]*(?!\s*&&|\s*\|\||\s*\?)/g,
        severity: 'medium',
        description: 'User input is used without validation',
        suggestion: 'Validate and sanitize all user inputs',
        languages: ['javascript', 'typescript']
      },
      {
        id: 'path_traversal',
        name: 'Path Traversal Vulnerability',
        pattern: /(\.\.\/|\.\.\\|\.\.[\/\\])/g,
        severity: 'high',
        description: 'Path traversal patterns detected',
        suggestion: 'Validate file paths and restrict access to allowed directories',
        languages: ['javascript', 'typescript', 'python', 'java', 'php', 'csharp']
      },

      // CSRF and security headers
      {
        id: 'missing_csrf_protection',
        name: 'Missing CSRF Protection',
        pattern: /app\.(post|put|patch|delete)\s*\([^)]*\)\s*,\s*(?!.*csrf)/gi,
        severity: 'medium',
        description: 'Endpoints may be vulnerable to CSRF attacks',
        suggestion: 'Implement CSRF protection for state-changing operations',
        languages: ['javascript', 'typescript']
      },

      // File upload vulnerabilities
      {
        id: 'unrestricted_file_upload',
        name: 'Unrestricted File Upload',
        pattern: /\.upload\(|multer\((?!.*fileFilter)/gi,
        severity: 'high',
        description: 'File upload without proper validation',
        suggestion: 'Validate file types, sizes, and scan for malware',
        languages: ['javascript', 'typescript']
      },

      // Information disclosure
      {
        id: 'debug_info_exposure',
        name: 'Debug Information Exposure',
        pattern: /(console\.log|print|echo|var_dump|print_r)\s*\([^)]*\b(password|token|secret|key|auth)\b/gi,
        severity: 'medium',
        description: 'Sensitive information may be exposed in debug output',
        suggestion: 'Remove debug statements or avoid logging sensitive data',
        languages: ['javascript', 'typescript', 'python', 'php']
      },

      // Insecure random
      {
        id: 'weak_random',
        name: 'Weak Random Number Generation',
        pattern: /Math\.random\(\)|random\(\)/gi,
        severity: 'medium',
        description: 'Weak random number generation for security purposes',
        suggestion: 'Use cryptographically secure random number generators',
        languages: ['javascript', 'typescript', 'python']
      },
    ];
  }

  async scanFile(file: File, scanId: number): Promise<ScanResult> {
    const vulnerabilities: Omit<InsertVulnerability, 'scanId'>[] = [];

    if (!file.content) {
      return { vulnerabilities: [], securityScore: 10 };
    }

    // Pattern-based scanning
    const patternVulns = await this.scanWithPatterns(file);
    vulnerabilities.push(...patternVulns);

    // AI-based scanning if available
    if (this.openai) {
      try {
        const aiVulns = await this.scanWithAI(file);
        vulnerabilities.push(...aiVulns);
      } catch (error) {
        console.error("AI scanning failed:", error);
        // Continue with pattern-based results only
      }
    }

    // Calculate security score
    const securityScore = this.calculateSecurityScore(vulnerabilities, file.content);

    return { vulnerabilities, securityScore };
  }

  async scanProject(files: File[], scanId: number): Promise<ScanResult> {
    const allVulnerabilities: Omit<InsertVulnerability, 'scanId'>[] = [];
    let totalLines = 0;

    for (const file of files) {
      if (file.content) {
        const fileResult = await this.scanFile(file, scanId);
        allVulnerabilities.push(...fileResult.vulnerabilities);
        totalLines += file.content.split('\n').length;
      }
    }

    // Calculate overall project security score
    const securityScore = this.calculateProjectSecurityScore(allVulnerabilities, totalLines);

    return { vulnerabilities: allVulnerabilities, securityScore };
  }

  async quickScan(code: string, language: string): Promise<ScanResult> {
    const vulnerabilities: Omit<InsertVulnerability, 'scanId'>[] = [];

    // Create a temporary file-like object for pattern scanning
    const tempFile: File = {
      id: 0,
      projectId: 0,
      name: 'temp',
      path: 'temp',
      content: code,
      language,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const patternVulns = await this.scanWithPatterns(tempFile);
    vulnerabilities.push(...patternVulns);

    // Quick AI scan if available
    if (this.openai) {
      try {
        const aiVulns = await this.scanWithAI(tempFile);
        vulnerabilities.push(...aiVulns);
      } catch (error) {
        console.error("AI quick scan failed:", error);
      }
    }

    const securityScore = this.calculateSecurityScore(vulnerabilities, code);

    return { vulnerabilities, securityScore };
  }

  private async scanWithPatterns(file: File): Promise<Omit<InsertVulnerability, 'scanId'>[]> {
    const vulnerabilities: Omit<InsertVulnerability, 'scanId'>[] = [];
    const lines = file.content?.split('\n') || [];

    for (const pattern of this.patterns) {
      // Check if pattern applies to this language
      if (file.language && !pattern.languages.includes(file.language)) {
        continue;
      }

      lines.forEach((line, lineIndex) => {
        const matches = line.matchAll(pattern.pattern);
        for (const match of matches) {
          vulnerabilities.push({
            fileId: file.id,
            type: pattern.id,
            severity: pattern.severity,
            title: pattern.name,
            description: pattern.description,
            lineNumber: lineIndex + 1,
            columnNumber: match.index || 0,
            codeSnippet: line.trim(),
            suggestion: pattern.suggestion,
            confidence: 0.85, // High confidence for pattern matches
            isFixed: false,
            detectionMethod: 'pattern',
          });
        }
      });
    }

    return vulnerabilities;
  }

  private async scanWithAI(file: File): Promise<Omit<InsertVulnerability, 'scanId'>[]> {
    if (!this.openai || !file.content) {
      return [];
    }

    try {
      const prompt = `Analyze the following ${file.language || 'code'} for security vulnerabilities. 
      Return a JSON array of vulnerabilities found. Each vulnerability should have:
      - type: string (vulnerability type like 'sql_injection', 'xss', etc.)
      - severity: 'low' | 'medium' | 'high' | 'critical'
      - title: string (brief title)
      - description: string (detailed description)
      - lineNumber: number (approximate line number, start from 1)
      - suggestion: string (how to fix it)
      - confidence: number (0.0 to 1.0)
      
      Code to analyze:
      \`\`\`${file.language || 'text'}
      ${file.content}
      \`\`\``;

      const response = await this.openai.chat.completions.create({
        model: "gpt-4o", // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
        messages: [
          {
            role: "system",
            content: "You are a security expert analyzing code for vulnerabilities. Respond with valid JSON only."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        response_format: { type: "json_object" },
        temperature: 0.1,
      });

      const result = JSON.parse(response.choices[0].message.content || '{"vulnerabilities": []}');
      const vulnerabilities = result.vulnerabilities || [];

      return vulnerabilities.map((vuln: any) => ({
        fileId: file.id,
        type: vuln.type || 'unknown',
        severity: vuln.severity || 'medium',
        title: vuln.title || 'Security Issue',
        description: vuln.description || 'Security vulnerability detected by AI analysis',
        lineNumber: vuln.lineNumber || 1,
        columnNumber: 0,
        codeSnippet: this.getCodeSnippet(file.content!, vuln.lineNumber || 1),
        suggestion: vuln.suggestion || 'Review and fix the security issue',
        confidence: Math.min(1.0, Math.max(0.0, vuln.confidence || 0.7)),
        isFixed: false,
        detectionMethod: 'ai',
      }));
    } catch (error) {
      console.error("AI vulnerability analysis failed:", error);
      return [];
    }
  }

  private getCodeSnippet(content: string, lineNumber: number): string {
    const lines = content.split('\n');
    const index = lineNumber - 1;
    if (index >= 0 && index < lines.length) {
      return lines[index].trim();
    }
    return '';
  }

  private calculateSecurityScore(vulnerabilities: Omit<InsertVulnerability, 'scanId'>[], code: string): number {
    if (!code || code.trim().length === 0) {
      return 10; // Empty code is "secure"
    }

    const linesOfCode = code.split('\n').length;
    let penaltyPoints = 0;

    // Calculate penalty based on vulnerability severity and count
    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'critical':
          penaltyPoints += 3.0;
          break;
        case 'high':
          penaltyPoints += 2.0;
          break;
        case 'medium':
          penaltyPoints += 1.0;
          break;
        case 'low':
          penaltyPoints += 0.5;
          break;
      }

      // Adjust penalty based on confidence
      penaltyPoints *= (vuln.confidence || 0.5);
    });

    // Normalize penalty based on code size (penalty per 100 lines of code)
    const normalizedPenalty = (penaltyPoints * 100) / Math.max(linesOfCode, 10);

    // Calculate score (10 is perfect, 0 is worst)
    const score = Math.max(0, 10 - normalizedPenalty);

    return Math.round(score * 10) / 10; // Round to 1 decimal place
  }

  private calculateProjectSecurityScore(vulnerabilities: Omit<InsertVulnerability, 'scanId'>[], totalLines: number): number {
    if (totalLines === 0) {
      return 10;
    }

    let totalPenalty = 0;
    const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
    const mediumCount = vulnerabilities.filter(v => v.severity === 'medium').length;
    const lowCount = vulnerabilities.filter(v => v.severity === 'low').length;

    // Weight penalties based on severity
    totalPenalty += criticalCount * 4.0;
    totalPenalty += highCount * 2.5;
    totalPenalty += mediumCount * 1.5;
    totalPenalty += lowCount * 0.5;

    // Normalize by project size (penalty per 1000 lines)
    const normalizedPenalty = (totalPenalty * 1000) / Math.max(totalLines, 100);

    // Calculate score
    const score = Math.max(0, 10 - (normalizedPenalty / 10));

    return Math.round(score * 10) / 10;
  }
}
