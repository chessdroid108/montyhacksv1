import OpenAI from "openai";

interface VulnerabilityPattern {
  id: string;
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  pattern: RegExp;
  category: string;
  suggestion: string;
}

interface Vulnerability {
  id: string;
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  line: number;
  category: string;
  suggestion: string;
  confidence: number;
  detectionMethod: 'pattern' | 'ai';
}

interface ScanResult {
  vulnerabilities: Vulnerability[];
  securityScore: number;
  scanDuration: number;
  language?: string;
}

export class VulnerabilityEngine {
  private openai: OpenAI | null = null;
  private patterns: VulnerabilityPattern[];

  constructor() {
    // Initialize OpenAI if API key is available
    const apiKey = process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY_ENV_VAR || process.env.API_KEY;
    if (apiKey) {
      this.openai = new OpenAI({ apiKey });
    }

    this.patterns = this.initializePatterns();
  }

  private initializePatterns(): VulnerabilityPattern[] {
    return [
      {
        id: 'sql-injection-1',
        name: 'SQL Injection - String Concatenation',
        description: 'Direct string concatenation in SQL queries allows injection attacks',
        severity: 'critical',
        pattern: /(\$\{[^}]*\}|['"`]\s*\+\s*\w+|query\s*=.*\+|SELECT.*\+.*FROM|INSERT.*\+.*VALUES)/gi,
        category: 'injection',
        suggestion: 'Use parameterized queries or prepared statements'
      },
      {
        id: 'sql-injection-2',
        name: 'SQL Injection - Template Literals',
        description: 'Template literals with user input in SQL queries',
        severity: 'critical',
        pattern: /`[^`]*\$\{[^}]*\}[^`]*`.*(?:SELECT|INSERT|UPDATE|DELETE)/gi,
        category: 'injection',
        suggestion: 'Use parameterized queries instead of template literals'
      },
      {
        id: 'xss-innerhtml',
        name: 'Cross-Site Scripting (XSS) - innerHTML',
        description: 'Direct assignment to innerHTML with user input',
        severity: 'high',
        pattern: /\.innerHTML\s*=\s*(?!['"`])|\$\([^)]*\)\.html\(/gi,
        category: 'xss',
        suggestion: 'Use textContent or properly sanitize HTML content'
      },
      {
        id: 'xss-eval',
        name: 'Code Injection - eval()',
        description: 'Use of eval() function can execute arbitrary code',
        severity: 'critical',
        pattern: /\beval\s*\(/gi,
        category: 'injection',
        suggestion: 'Avoid using eval(). Use JSON.parse() for JSON data or implement specific parsing logic'
      },
      {
        id: 'auth-hardcoded-secrets',
        name: 'Hardcoded Credentials',
        description: 'Hardcoded passwords or API keys in source code',
        severity: 'high',
        pattern: /(password|pwd|pass|secret|key|token|api_key)\s*[:=]\s*['"`][^'"`\s]{8,}/gi,
        category: 'authentication',
        suggestion: 'Store credentials in environment variables or secure configuration files'
      },
      {
        id: 'crypto-weak-random',
        name: 'Weak Random Number Generation',
        description: 'Use of Math.random() for security-sensitive operations',
        severity: 'medium',
        pattern: /Math\.random\(\)/gi,
        category: 'cryptography',
        suggestion: 'Use crypto.randomBytes() or crypto.getRandomValues() for cryptographic purposes'
      },
      {
        id: 'path-traversal',
        name: 'Path Traversal',
        description: 'Potential path traversal vulnerability',
        severity: 'high',
        pattern: /\.\.[\/\\]|path\.join\([^)]*\.\./gi,
        category: 'injection',
        suggestion: 'Validate and sanitize file paths, use path.resolve() carefully'
      },
      {
        id: 'command-injection',
        name: 'Command Injection',
        description: 'Potential command injection through exec or spawn',
        severity: 'critical',
        pattern: /(exec|spawn|system)\s*\([^)]*\$\{|child_process\.(exec|spawn)/gi,
        category: 'injection',
        suggestion: 'Validate input and use parameterized commands or allowlists'
      },
      {
        id: 'cors-wildcard',
        name: 'CORS Misconfiguration',
        description: 'Overly permissive CORS configuration',
        severity: 'medium',
        pattern: /Access-Control-Allow-Origin['":\s]*\*/gi,
        category: 'configuration',
        suggestion: 'Specify exact origins instead of using wildcard (*)'
      },
      {
        id: 'weak-crypto',
        name: 'Weak Cryptographic Algorithm',
        description: 'Use of weak or deprecated cryptographic algorithms',
        severity: 'medium',
        pattern: /(md5|sha1|des|3des|rc4)\s*\(/gi,
        category: 'cryptography',
        suggestion: 'Use stronger algorithms like SHA-256, AES-256, or modern alternatives'
      },
      {
        id: 'insecure-http',
        name: 'Insecure HTTP Usage',
        description: 'Use of HTTP instead of HTTPS for sensitive operations',
        severity: 'medium',
        pattern: /http:\/\/(?!localhost|127\.0\.0\.1)/gi,
        category: 'configuration',
        suggestion: 'Use HTTPS for all external communications'
      },
      {
        id: 'input-validation',
        name: 'Missing Input Validation',
        description: 'Direct use of user input without validation',
        severity: 'medium',
        pattern: /(req\.body|req\.query|req\.params)\.[a-zA-Z_$][a-zA-Z0-9_$]*(?!\s*&&|\s*\|\||\s*\?|\s*===|\s*!==|\s*==|\s*!=)/gi,
        category: 'validation',
        suggestion: 'Implement proper input validation and sanitization'
      }
    ];
  }

  private detectLanguage(code: string, fileName?: string): string {
    if (fileName) {
      const extension = fileName.split('.').pop()?.toLowerCase();
      const languageMap: { [key: string]: string } = {
        'js': 'javascript',
        'jsx': 'javascript',
        'ts': 'typescript',
        'tsx': 'typescript',
        'py': 'python',
        'php': 'php',
        'java': 'java',
        'c': 'c',
        'cpp': 'cpp',
        'cs': 'csharp',
        'rb': 'ruby',
        'go': 'go'
      };
      if (extension && languageMap[extension]) {
        return languageMap[extension];
      }
    }

    // Fallback: detect by patterns
    if (/\b(function|const|let|var|=>\s*{)\b/gi.test(code)) return 'javascript';
    if (/\b(interface|type|enum)\s+\w+/gi.test(code)) return 'typescript';
    if (/\b(def|import|from)\s+\w+/gi.test(code)) return 'python';
    if (/\b(class|public|private|protected)\s+\w+/gi.test(code)) return 'java';
    if (/\b(\$[a-zA-Z_]|\?php)\b/gi.test(code)) return 'php';
    
    return 'unknown';
  }

  private async performPatternMatching(code: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    const lines = code.split('\n');

    for (const pattern of this.patterns) {
      let match;
      while ((match = pattern.pattern.exec(code)) !== null) {
        // Find line number
        const beforeMatch = code.substring(0, match.index);
        const lineNumber = beforeMatch.split('\n').length;
        
        vulnerabilities.push({
          id: pattern.id,
          name: pattern.name,
          description: pattern.description,
          severity: pattern.severity,
          line: lineNumber,
          category: pattern.category,
          suggestion: pattern.suggestion,
          confidence: 0.85, // High confidence for pattern matching
          detectionMethod: 'pattern'
        });
      }
      
      // Reset regex lastIndex to prevent issues with global flag
      pattern.pattern.lastIndex = 0;
    }

    return vulnerabilities;
  }

  private async performAIAnalysis(code: string, language: string): Promise<Vulnerability[]> {
    if (!this.openai) {
      return []; // AI analysis not available
    }

    try {
      const prompt = `Analyze the following ${language} code for security vulnerabilities. 
      Focus on identifying potential security issues that pattern matching might miss.
      Return a JSON array of vulnerabilities with the following structure:
      [
        {
          "id": "unique_id",
          "name": "vulnerability_name",
          "description": "detailed_description",
          "severity": "low|medium|high|critical",
          "line": line_number,
          "category": "category_name",
          "suggestion": "how_to_fix",
          "confidence": confidence_score_0_to_1
        }
      ]

      Code to analyze:
      \`\`\`${language}
      ${code}
      \`\`\``;

      // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
      const response = await this.openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          {
            role: "system",
            content: "You are a security expert specializing in code vulnerability analysis. Analyze code for security issues and respond with valid JSON only."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        response_format: { type: "json_object" },
        temperature: 0.1, // Low temperature for consistent results
      });

      const aiResult = JSON.parse(response.choices[0].message.content || '{"vulnerabilities": []}');
      const vulnerabilities = aiResult.vulnerabilities || aiResult || [];

      return vulnerabilities.map((vuln: any) => ({
        ...vuln,
        detectionMethod: 'ai' as const,
        confidence: Math.min(Math.max(vuln.confidence || 0.7, 0), 1) // Ensure confidence is between 0 and 1
      }));

    } catch (error) {
      console.error('AI analysis failed:', error);
      return [];
    }
  }

  private calculateSecurityScore(vulnerabilities: Vulnerability[]): number {
    if (vulnerabilities.length === 0) return 100;

    // Weight vulnerabilities by severity
    const severityWeights = {
      'critical': 25,
      'high': 15,
      'medium': 8,
      'low': 3
    };

    let totalPenalty = 0;
    for (const vuln of vulnerabilities) {
      const weight = severityWeights[vuln.severity] || 5;
      const confidenceMultiplier = vuln.confidence;
      totalPenalty += weight * confidenceMultiplier;
    }

    // Calculate score (max penalty caps at 100 for severe cases)
    const score = Math.max(0, 100 - Math.min(totalPenalty, 100));
    return Math.round(score);
  }

  private removeDuplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set<string>();
    return vulnerabilities.filter(vuln => {
      const key = `${vuln.name}-${vuln.line}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  public async scanCode(code: string, fileName?: string): Promise<ScanResult> {
    const startTime = Date.now();
    
    const language = this.detectLanguage(code, fileName);
    
    // Perform pattern-based analysis
    const patternVulnerabilities = await this.performPatternMatching(code);
    
    // Perform AI-based analysis if available
    const aiVulnerabilities = await this.performAIAnalysis(code, language);
    
    // Combine and deduplicate results
    const allVulnerabilities = [...patternVulnerabilities, ...aiVulnerabilities];
    const uniqueVulnerabilities = this.removeDuplicateVulnerabilities(allVulnerabilities);
    
    // Sort by severity and confidence
    const severityOrder = { 'critical': 0, 'high': 1, 'medium': 2, 'low': 3 };
    uniqueVulnerabilities.sort((a, b) => {
      const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
      if (severityDiff !== 0) return severityDiff;
      return b.confidence - a.confidence; // Higher confidence first
    });

    const securityScore = this.calculateSecurityScore(uniqueVulnerabilities);
    const scanDuration = Date.now() - startTime;

    return {
      vulnerabilities: uniqueVulnerabilities,
      securityScore,
      scanDuration,
      language
    };
  }

  public async scanMultipleFiles(files: { [fileName: string]: string }): Promise<ScanResult> {
    const startTime = Date.now();
    const allVulnerabilities: Vulnerability[] = [];
    let totalLines = 0;

    for (const [fileName, code] of Object.entries(files)) {
      const fileResult = await this.scanCode(code, fileName);
      allVulnerabilities.push(...fileResult.vulnerabilities);
      totalLines += code.split('\n').length;
    }

    const uniqueVulnerabilities = this.removeDuplicateVulnerabilities(allVulnerabilities);
    const securityScore = this.calculateSecurityScore(uniqueVulnerabilities);
    const scanDuration = Date.now() - startTime;

    return {
      vulnerabilities: uniqueVulnerabilities,
      securityScore,
      scanDuration
    };
  }
}
